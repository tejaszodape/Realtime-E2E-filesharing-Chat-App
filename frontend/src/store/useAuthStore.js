import { create } from "zustand";
import { axiosInstance } from "../lib/axios.js";
import toast from "react-hot-toast";
import { io } from "socket.io-client";

const BASE_URL = import.meta.env.MODE === "development" ? "http://localhost:5001" : "/";

// Utility: Convert ArrayBuffer to Base64
const arrayBufferToBase64 = (buffer) =>
  btoa(String.fromCharCode(...new Uint8Array(buffer)));

// Utility: Convert Base64 to ArrayBuffer
const base64ToArrayBuffer = (base64) => {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
};

// Function to derive a key from the password using PBKDF2 (must match signup)
async function deriveKeyFromPassword(password, saltBuffer, iterations = 100000) {
  const enc = new TextEncoder();
  const keyMaterial = await window.crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );
  return window.crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: saltBuffer, // Pass the ArrayBuffer directly
      iterations: iterations,
      hash: "SHA-256",
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"] // Need decrypt permission
  );
}

// Function to decrypt data using AES-GCM (must match signup encryption)
async function decryptData(key, encryptedDataBuffer, ivBuffer) {
  try {
    const decryptedBuffer = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: ivBuffer, // Pass the ArrayBuffer directly
      },
      key,
      encryptedDataBuffer // Pass the ArrayBuffer directly
    );
    return decryptedBuffer; // Returns ArrayBuffer
  } catch (decryptError) {
    console.error("Decryption failed:", decryptError);
    throw new Error("Failed to decrypt private key. Incorrect password or corrupted data.");
  }
}

export const useAuthStore = create((set, get) => ({
  authUser: null,
  privateKey: null,
  isSigningUp: false,
  isLoggingIn: false,
  isUpdatingProfile: false,
  isCheckingAuth: true,
  onlineUsers: [],
  socket: null,

  setPrivateKey: (key) => set({ privateKey: key }),

  checkAuth: async () => {
    try {
      const res = await axiosInstance.get("/auth/check");
      set({ authUser: res.data });

      // Load privateKey from localStorage (if user logged in previously in this session)
      const pk = localStorage.getItem("privateKey");
      if (pk) {
        console.log("ðŸ”“ Private key loaded from localStorage in checkAuth");
        set({ privateKey: pk });
      } else {
        console.log("âš ï¸ No private key found in localStorage during checkAuth");
        // Optionally, if encrypted key data was sent by checkAuth and you want to trigger
        // a password prompt for recovery, you could do it here.
        // However, typically checkAuth doesn't have the password.
      }

      get().connectSocket();
    } catch (error) {
      console.log("Error in checkAuth:", error?.response?.data || error?.message || error);
      set({ authUser: null, privateKey: null }); // Ensure privateKey is also cleared on auth error
    } finally {
      set({ isCheckingAuth: false });
    }
  },

   // --- Replace your existing signup function with this one ---
    // --- Replace your existing signup function with this one ---
  signup: async (data) => {
    set({ isSigningUp: true });
    console.log("ðŸš€ Signup data received in useAuthStore:", data); // Log to verify incoming data

    // --- Validation ---
    // Check for the basic fields SignUpPage.jsx sends (name/email/password are inside formData)
    if (!data.fullName || !data.email || !data.password) {
      toast.error("Name, email, and password are required.");
      console.log("âŒ Missing basic fields:", {
        fullName: !!data.fullName,
        email: !!data.email,
        password: !!data.password,
      });
      set({ isSigningUp: false });
      return;
    }

    // Check for the cryptographic fields generated by SignUpPage.jsx
    if (!data.publicKey || !data.encryptedPrivateKey || !data.keySalt || !data.keyIv) {
      toast.error("Missing cryptographic data. Please try again.");
      console.log("âŒ Missing cryptographic fields:", {
        publicKey: !!data.publicKey,
        encryptedPrivateKey: !!data.encryptedPrivateKey,
        keySalt: !!data.keySalt,
        keyIv: !!data.keyIv,
      });
      set({ isSigningUp: false });
      return;
    }
    // --- End Validation ---

    try {
      // --- Use data prepared by SignUpPage.jsx ---
      // No need to regenerate keys here, SignUpPage.jsx already did it.
      const publicKeyBase64 = data.publicKey;
      const privateKeyBase64 = arrayBufferToBase64(base64ToArrayBuffer(data.encryptedPrivateKey)); // This is just a placeholder now, we have the encrypted one.

      // --- Send data to backend ---
      // Ensure field names match backend expectations exactly.
      // Backend expects: name, email, password, publicKey, encryptedPrivateKey, iv, salt
      console.log("ðŸ“¤ Sending signup data to backend /auth/signup");
      const res = await axiosInstance.post("/auth/signup", {
        name: data.fullName, // Backend expects 'name', SignUpPage sends 'fullName'
        email: data.email,
        password: data.password,
        publicKey: data.publicKey,         // Use publicKey from SignUpPage
        encryptedPrivateKey: data.encryptedPrivateKey, // Include encrypted key data from SignUpPage
        iv: data.keyIv,   // Backend expects 'iv', SignUpPage sends 'keyIv'
        salt: data.keySalt, // Backend expects 'salt', SignUpPage sends 'keySalt'
      });
      // --- End Send data to backend ---

      // --- Post-Signup Actions ---
      // Store the plaintext private key locally for immediate use in the current session.
      // SignUpPage.jsx generated the plaintext key and stored it.
      // If you modify SignUpPage.jsx to pass plaintextPrivateKeyBase64 in signupData, use it here:
      // localStorage.setItem("privateKey", data.plaintextPrivateKeyBase64);
      // set({ privateKey: data.plaintextPrivateKeyBase64 });
      // For now, since SignUpPage stores it, we just need to make sure it's loaded if needed elsewhere.
      // Or, if you want useAuthStore to handle it based on the response:
      // But the response likely doesn't include the plaintext key.
      // So, rely on SignUpPage storing it, or pass it through 'data'.
      // Let's assume SignUpPage handles local storage for the plaintext key.
      // --- End Post-Signup Actions ---

      set({ authUser: res.data });
      toast.success("Account created successfully");
      get().connectSocket();
    } catch (error) {
      console.error("âŒ Signup failed in useAuthStore:", error);
      // Improved error handling
      if (error.response) {
        console.error("âŒ Signup Error Response Data:", error.response.data);
        console.error("âŒ Signup Error Status:", error.response.status);
        toast.error(error.response.data?.message || `Signup failed (${error.response.status})`);
      } else if (error.request) {
        console.error("âŒ Signup No Response Received:", error.request);
        toast.error("No response from server. Please check your connection.");
      } else {
        console.error("âŒ Signup Error Setting up Request:", error.message);
        toast.error("Signup request failed. Please try again.");
      }
    } finally {
      set({ isSigningUp: false });
    }
  },
  // --- End of Updated Signup Function ----
  // --- End of Updated Signup Function ---

  login: async (data) => { // 'data' is expected to contain { email, password }
    console.log("useAuthStore: login function invoked with data:", data); 
    set({ isLoggingIn: true });
    try {
      // 1. Perform login API call
      console.log("ðŸ” Attempting login for:", data.email);
      const res = await axiosInstance.post("/auth/login", data);
      console.log("âœ… Login successful. Response ", res.data);

      // 2. Set authenticated user
      set({ authUser: res.data });

      // 3. Handle Private Key Retrieval and Decryption
      let privateKeyBase64 = null;

      // a. Check localStorage first (user might have logged in before in this session)
      privateKeyBase64 = localStorage.getItem("privateKey");
      console.log("ðŸ” Checked localStorage for private key:", !!privateKeyBase64);

      // b. If not in localStorage, attempt to decrypt from server data
      if (!privateKeyBase64 &&
          res.data.encryptedPrivateKey &&
          res.data.keySalt && // Backend sends keySalt
          res.data.keyIv) {   // Backend sends keyIv
        console.log("ðŸ” Private key not in localStorage. Attempting to decrypt from server data...");
        try {
          // i. Convert base64 server data back to ArrayBuffers
          const encryptedPrivateKeyBuffer = base64ToArrayBuffer(res.data.encryptedPrivateKey);
          const saltBuffer = base64ToArrayBuffer(res.data.keySalt); // Use keySalt from backend response
          const ivBuffer = base64ToArrayBuffer(res.data.keyIv);     // Use keyIv from backend response

          // ii. Derive the decryption key using the login password and stored salt
          console.log("ðŸ”‘ Deriving decryption key...");
          const decryptionKey = await deriveKeyFromPassword(data.password, saltBuffer);

          // iii. Decrypt the private key
          console.log("ðŸ”“ Decrypting private key...");
          const decryptedPrivateKeyBuffer = await decryptData(decryptionKey, encryptedPrivateKeyBuffer, ivBuffer);

          // iv. Convert decrypted ArrayBuffer back to Base64 for storage
          privateKeyBase64 = arrayBufferToBase64(decryptedPrivateKeyBuffer);
          console.log("âœ… Private key successfully decrypted.");

          // v. Store the decrypted private key in localStorage for future use in this session
          localStorage.setItem("privateKey", privateKeyBase64);
          console.log("ðŸ’¾ Decrypted private key stored in localStorage.");

        } catch (decryptError) {
          console.error("âŒ Error during private key decryption:", decryptError);
          toast.error(decryptError.message || "Failed to decrypt private key. Please try logging in again.");
          // Consider if you want to proceed with login but without the private key,
          // or if this is a critical failure. For E2E, it's usually critical.
          // For now, let's clear authUser and treat it as a login failure.
          set({ authUser: null });
          throw decryptError; // Re-throw to be caught by the outer catch
        }
      } else if (!privateKeyBase64) {
        // c. If neither in localStorage nor server data available
        console.warn("âš ï¸ Private key not available locally or from server response.");
        toast.error("Private key could not be retrieved. Some features might be unavailable.");
        // Depending on your app's requirements, you might want to handle this differently.
        // Maybe logout immediately, or allow limited functionality.
      }

      // 4. Set the private key in the store (from localStorage or newly decrypted)
      if (privateKeyBase64) {
        set({ privateKey: privateKeyBase64 });
        console.log("ðŸ”‘ Private key set in store.");
      }

      // 5. Connect socket and show success
      toast.success("Logged in successfully");
      get().connectSocket();
    } catch (error) {
      console.error("Login failed:", error?.response?.data || error?.message || error);
      // Clear any potentially set state on error
      set({ authUser: null, privateKey: null });
      // Improved error handling for login
      if (error.response) {
        toast.error(error.response.data?.message || `Login failed (${error.response.status})`);
      } else if (error.request) {
        toast.error("No response from server. Please check your connection.");
      } else {
        toast.error(error.message || "Login request failed.");
      }
    } finally {
      set({ isLoggingIn: false });
    }
  },

  logout: async () => {
    try {
      await axiosInstance.post("/auth/logout");
      localStorage.removeItem("privateKey");
      set({ authUser: null, privateKey: null });
      toast.success("Logged out successfully");
      get().disconnectSocket();
    } catch (error) {
      toast.error(error?.response?.data?.message || "Logout failed");
    }
  },

  updateProfile: async (data) => {
    set({ isUpdatingProfile: true });
    try {
      const res = await axiosInstance.put("/auth/update-profile", data);
      set({ authUser: res.data });
      toast.success("Profile updated successfully");
    } catch (error) {
      console.log("error in update profile:", error);
      toast.error(error.response?.data?.message || "Update failed");
    } finally {
      set({ isUpdatingProfile: false });
    }
  },

  connectSocket: () => {
    const { authUser } = get();
    if (!authUser || get().socket?.connected) return;

    const socket = io(BASE_URL, {
      query: { userId: authUser._id },
    });

    socket.on("connect", () => {
       console.log("ðŸ”Œ Socket connected");
    });

    socket.on("connect_error", (error) => {
      console.error("ðŸ”Œ Socket connection error:", error);
    });

    socket.on("disconnect", (reason) => {
       console.log("ðŸ”Œ Socket disconnected:", reason);
    });

    socket.on("getOnlineUsers", (userIds) => {
      set({ onlineUsers: userIds });
    });

    socket.connect(); // Explicit connect call
    set({ socket });
  },

  disconnectSocket: () => {
    const { socket } = get();
    if (socket?.connected) {
      socket.disconnect();
      console.log("ðŸ”Œ Socket manually disconnected");
    }
    // Optionally clear socket reference
    // set({ socket: null });
  },
}));